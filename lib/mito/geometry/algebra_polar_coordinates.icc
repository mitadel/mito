// -*- c++ -*-
//
// Copyright (c) 2020-2024, the MiTo Authors, all rights reserved
//

// code guard
#if !defined(mito_geometry_algebra_polar_coordinates_h)
#define mito_geometry_algebra_polar_coordinates_h


namespace mito::geometry {

    // addition of polar coordinates {A} and vector {v} stemming from point A
    template <>
    constexpr auto operator+(const Coordinates<2, POLAR> & A, const vector_t<2> & v)
        -> Coordinates<2, POLAR>
    {
        // get r and theta of point A
        const auto & r_A = A._array[0];
        const auto & theta_A = A._array[1];

        // get the radial and hoop component of vector {v}
        const auto & v_r = v[0];
        const auto v_theta = v[1] / r_A;

        // compute r and theta of point B, which is point A plus vector {v}
        auto r_B = std::sqrt((r_A + v_r) * (r_A + v_r) + v_theta * r_A * v_theta * r_A);
        auto theta_B = theta_A + std::atan2(v_theta * r_A, r_A + v_r);

        // all done
        return Coordinates<2, POLAR>({ r_B, theta_B });
    }

    // subtraction of coordinates A - B, returns a vector stemming from B
    template <>
    constexpr auto operator-(const Coordinates<2, POLAR> & A, const Coordinates<2, POLAR> & B)
        -> mito::vector_t<2>
    {
        // get the radius and angle of the two points
        const auto & r_A = A._array[0];
        const auto & r_B = B._array[0];
        const auto & theta_A = A._array[1];
        const auto & theta_B = B._array[1];

        return { r_A * std::cos(theta_A - theta_B) - r_B, r_A * std::sin(theta_A - theta_B) };
    }
}


#endif

// end of file
