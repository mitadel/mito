// -*- c++ -*-
//
// Copyright (c) 2020-2024, the MiTo Authors, all rights reserved
//


#if !defined(mito_materials_numerical_icc)
#error This header file contains implementation details of the functions in numerical.h
#else


auto
mito::materials::numerical_stress(
    const auto & material, const mito::matrix_c auto & Du, const mito::real eps)
    -> mito::matrix_t<3>
{
    // take note of the original deformation gradient
    auto Du_perturbed = Du;

    // initialize the numerical stress tensor
    auto P_numerical = mito::matrix_t<3>();

    // for each component of the deformation gradient
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {

            // make a positive perturbation in direction {i, j}
            Du_perturbed[{ i, j }] = Du[{ i, j }] + eps;
            // compute the energy {q_plus} in the perturbed state
            auto q_plus = material.energy(Du_perturbed);

            // make a negative perturbation in direction {i, j}
            Du_perturbed[{ i, j }] = Du[{ i, j }] - eps;
            // compute the energy {q_minus} in the perturbed state
            auto q_minus = material.energy(Du_perturbed);

            // compute the stress as the numerical directional derivative of the energy with respect
            // to the deformation gradient
            P_numerical[{ i, j }] = (q_plus - q_minus) / (2.0 * eps);

            // go back to the original state {i, j}
            Du_perturbed[{ i, j }] = Du[{ i, j }];
        }
    }

    // all done
    return P_numerical;
}

auto
mito::materials::numerical_tangent(
    const auto & material, const mito::matrix_c auto & Du, const mito::real eps)
    -> mito::fourth_order_tensor_t<3>
{
    // take note of the original deformation gradient
    auto Du_perturbed = Du;

    // initialize the numerical tangent tensor
    auto C_numerical = mito::fourth_order_tensor_t<3>();

    // for each component of the deformation gradient
    for (int k = 0; k < 3; k++) {
        for (int l = 0; l < 3; l++) {

            // make a positive perturbation in direction {k, l}
            Du_perturbed[{ k, l }] = Du[{ k, l }] + eps;
            // compute the stress {P_plus} in the perturbed state
            auto P_plus = material.stress(Du_perturbed);

            // make a negative perturbation in direction {k, l}
            Du_perturbed[{ k, l }] = Du[{ k, l }] - eps;
            // compute the stress {P_minus} in the perturbed state
            auto P_minus = material.stress(Du_perturbed);

            // compute the tangent as the numerical directional derivative of the stress with
            // respect to the deformation gradient
            for (int i = 0; i < 3; i++) {
                for (int j = 0; j < 3; j++) {
                    C_numerical[{ i, j, k, l }] =
                        (P_plus[{ i, j }] - P_minus[{ i, j }]) / (2.0 * eps);
                }
            }

            // go back to the original state {k, l}
            Du_perturbed[{ k, l }] = Du[{ k, l }];
        }
    }

    // all done
    return C_numerical;
}


#endif
// end of file
