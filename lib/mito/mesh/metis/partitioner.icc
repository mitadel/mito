// code guard
#if !defined(mito_mesh_metis_partitioner_icc)
#error this file contains implementation details for metis mesh partitioner
#else


// TOFIX: the trick of empty namespaces in icc files does not work, move all these functions to
//          the mito::mesh::metis namespace
// helper functions
namespace {

    using vertex_t = mito::topology::vertex_t;
    using edge_t = mito::topology::segment_t;

    // QUESTION: should these methods belong to the interface of class {Mesh}?
    template <class meshT>
    auto populate_collection_of_vertices(const meshT & mesh) -> std::vector<vertex_t>
    {
        // a set collecting all the vertices (without repeated entries)
        std::set<vertex_t> vertex_collection;

        // populate the {vertex_collection}
        // loop on cells in {mesh}
        for (const auto & cell : mesh.cells()) {
            // append vertices of current cell to {vertex_collection}
            cell->vertices(vertex_collection);
        }

        // a vector with all vertices
        std::vector<vertex_t> id_to_vertex(vertex_collection.begin(), vertex_collection.end());

        // all done
        return id_to_vertex;
    }

    auto populate_vertices_map(const std::vector<vertex_t> & id_to_vertex)
        -> std::map<vertex_t, int>
    {
        // a map between a vertex and an integer id
        std::map<vertex_t, int> vertex_to_id;

        // populate the {vertex_to_id} map
        for (size_t id = 0; id < id_to_vertex.size(); ++id) {
            vertex_to_id[id_to_vertex[id]] = id;
        }

        // all done
        return vertex_to_id;
    }

    template <class meshT>
    auto order_mesh_cells(const meshT & mesh) -> auto
    {
        // extract the geometric information from mesh
        const auto & geometry = mesh.geometry();

        // define operator< for cells, given a geometry
        auto cell_compare = [&geometry](
                                const typename meshT::cell_t & cell_a,
                                const typename meshT::cell_t & cell_b) -> bool {
            // get the barycenter of {cell_a}
            auto barycenter_a = mito::geometry::barycenter(cell_a, geometry);
            // get the barycenter of {cell_a}
            auto barycenter_b = mito::geometry::barycenter(cell_b, geometry);
            // return lexicographical comparison of the barycenters
            return barycenter_a < barycenter_b;
        };

        // an ordered set of cells
        std::set<typename meshT::cell_t, decltype(cell_compare)> cells(cell_compare);

        // insert mesh cells in ordered set
        for (const auto & cell : mesh.cells()) {
            cells.insert(cell);
        }

        // return ordered set of cells
        return cells;
    }

    template <class meshT>
    auto metis_paint_partition(
        const meshT & mesh, const auto & cells, const std::map<vertex_t, int> & vertex_to_id,
        int n_partitions) -> std::vector<idx_t>
    {
        // typedef mesh type
        using mesh_t = meshT;

        // get the total number of vertices in the mesh
        int n_vertices = mesh.geometry().point_cloud().size();

        // get the total number of cells in the mesh
        int n_elements = mesh.cells().size();

        // idx_t objval;
        std::vector<idx_t> painting(n_elements, 0);

        // METIS common nodes that two elements must share to be considered adjacent elements
        // NOTE: not general: n_common is equal to simplex order only in case of simplicial cells
        int n_common = mesh_t::order;

        // number of vertices per element in this mesh type
        int n_vertices_per_element = mesh_t::n_vertices;

        // the element connectivity
        std::vector<int> element_connectivity(n_elements * n_vertices_per_element);

        const auto & geometry = mesh.geometry();

        auto cmp = [&geometry](const vertex_t & a, const vertex_t & b) -> bool {
            auto position_a = geometry.point(a)->coordinates();
            auto position_b = geometry.point(b)->coordinates();

            return position_a < position_b;
        };
        std::set<vertex_t, decltype(cmp)> vertices(cmp);

        // cell counter
        int e = 0;
        // loop on cells
        for (const auto & cell : cells) {
            // spatially order cell vertices
            for (const auto & vertex : cell->vertices()) {
                vertices.insert(vertex);
            }
            // vertices counter
            int v = 0;
            for (const auto & vertex : vertices) {
                // populate element connectivity with the id of each of its vertices
                element_connectivity[n_vertices_per_element * e + v] = vertex_to_id.at(vertex);
                // increment
                ++v;
            }
            // clear cell vertices
            vertices.clear();

            // increment
            ++e;
        }

        std::vector<int> element_index(n_elements + 1, 0);
        int node_index = 0;
        for (size_t i = 0; i < element_index.size(); ++i, node_index += n_vertices_per_element) {
            element_index[i] = node_index;
        }

        // Define the options for METIS
        idx_t options[METIS_NOPTIONS];
        METIS_SetDefaultOptions(options);

        // setup METIS variable which is counting the number of cut edges: NOT USEFUL
        int edgecut = 0;

        // create an array for the procId per node: NOT USEFUL
        int * npart = new int[n_vertices];

        int metisResult = METIS_PartMeshDual(
            &n_elements, &n_vertices, element_index.data(), element_connectivity.data(), NULL, NULL,
            &n_common, &n_partitions, NULL, options, &edgecut, painting.data(), npart);

        // assert that metis ran correctly
        assert(metisResult == 1);

        // all done
        return painting;
    }
}


template <class meshT>
auto
mito::mesh::metis::partition(const meshT & mesh, int n_partitions, int n_rank) -> meshT
{
    // typedef mesh type
    using mesh_t = meshT;

    // a collection of all the vertices
    // TOFIX: this container is not used, consider merging {populate_collection_of_vertices} and
    //          {populate_vertices_map}
    auto id_to_vertex = populate_collection_of_vertices(mesh);

    // a map between the vertices and an integer id
    auto vertex_to_id = populate_vertices_map(id_to_vertex);

    // get the mesh cells in with a lexicographic order on the barycenter
    auto cells = order_mesh_cells(mesh);

    // call metis partitioner
    auto painting = metis_paint_partition(mesh, cells, vertex_to_id, n_partitions);

    // debug
    // std::cout << "partition" << std::endl;
    // for (size_t part_i = 0; part_i < painting.size(); part_i++) {
    //     std::cout << part_i << " " << painting[part_i] << std::endl;
    // }

    // an empty mesh of same type of the original mesh
    auto partitioned_mesh = mesh_t(mesh.geometry());

    // cell counter
    int e = 0;
    // loop on cells
    for (const auto & cell : cells) {
        //
        if (painting[e] == n_rank) {
            partitioned_mesh.insert(cell);
        }
        // increment
        ++e;
    }

    // all done
    return partitioned_mesh;
}


#endif

// end of file
