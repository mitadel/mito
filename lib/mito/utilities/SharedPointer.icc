// -*- C++ -*-
//

#if !defined(mito_utilities_SharedPointer_icc)
#error This header file contains implementation details of class mito::utilities::SharedPointer
#else

template <class Resource>
auto
mito::utilities::SharedPointer<Resource>::id() const -> index_t<Resource>
{
    // the id is the (immutable) address of this object
    return reinterpret_cast<index_t<Resource>>(_handle);
}

template <class Resource>
auto
mito::utilities::SharedPointer<Resource>::resource(index_t<Resource> index) -> handle_t
{
    // the id is the (immutable) address of this object
    return reinterpret_cast<handle_t>(index);
}

// interface
template <class Resource>
auto
mito::utilities::SharedPointer<Resource>::handle() const noexcept
    -> mito::utilities::SharedPointer<Resource>::handle_t
{
    // return the handle
    return _handle;
}

template <class Resource>
auto
mito::utilities::SharedPointer<Resource>::references() const -> int
{
    // return the count of outstanding references
    return _handle->_references();
}

template <class Resource>
auto
mito::utilities::SharedPointer<Resource>::reset() -> void
{
    // QUESTION:
    // Perhaps this method should not exist, but the destructor of SharedPointer should be called
    // instead and then the instance should be swapped for a bad item
    // release my current handle
    _release();

    // invalidate handle to the resource
    _handle = nullptr;

    // invalidate handle to the segmented container
    _container = nullptr;

    // all done
    return;
}

template <class Resource>
auto
mito::utilities::SharedPointer<Resource>::is_nullptr() const noexcept -> bool
{
    // QUESTION: perhaps this method should be removed?
    // all done
    return _handle == nullptr;
}

// operator->
template <class Resource>
auto
mito::utilities::SharedPointer<Resource>::operator->() const
    -> mito::utilities::SharedPointer<Resource>::handle_t
{
    // return the handle
    return _handle;
}

// // operator*
// template <class Resource>
// auto
// mito::utilities::SharedPointer<Resource>::operator*() const
//     -> const mito::utilities::SharedPointer<Resource>::resource_t &
// {
//     // return the resource
//     return *_handle;
// }

// destructor
template <class Resource>
mito::utilities::SharedPointer<Resource>::~SharedPointer()
{
    // release my current handle
    _release();
}

// default constructor (invalid shared handle)
template <class Resource>
mito::utilities::SharedPointer<Resource>::SharedPointer() : _handle(nullptr), _container(nullptr)
{}

// the constructor
template <class Resource>
mito::utilities::SharedPointer<Resource>::SharedPointer(
    handle_t resource, segmented_t<shared_ptr_t> * container) :
    _handle(resource),
    _container(container)
{
    // grab a reference to the shared handle
    _acquire();
}

// the copy constructor
template <class Resource>
mito::utilities::SharedPointer<Resource>::SharedPointer(
    const mito::utilities::SharedPointer<Resource> & other) :
    _handle(other._handle),
    _container(other._container)
{
    // grab a reference to the shared handle
    _acquire();
}

// the move constructor
template <class Resource>
mito::utilities::SharedPointer<Resource>::SharedPointer(
    mito::utilities::SharedPointer<Resource> && other) noexcept :
    _handle(other._handle),
    _container(other._container)
{
    // and grab a reference to the new shareable
    _acquire();

    // invalidate {other} with the bad item of the segmented container
    auto bad_item = segmented_t<shared_ptr_t>::bad_item();
    other = bad_item;
}

// assignment operator
template <class Resource>
mito::utilities::SharedPointer<Resource> &
mito::utilities::SharedPointer<Resource>::operator=(
    const mito::utilities::SharedPointer<Resource> & other)
{
    // if {other} and I point to different handles
    if (other._handle != _handle) {
        // release my current handle
        _release();
        // adopt the new shareable
        _handle = other._handle;
        // and grab a reference to it
        _acquire();
        // grab the container handle
        _container = other._container;
    }

    // all done
    return *this;
}

// move assignment operator
template <class Resource>
mito::utilities::SharedPointer<Resource> &
mito::utilities::SharedPointer<Resource>::operator=(
    mito::utilities::SharedPointer<Resource> && other)
{
    // if {other} and I point to different handles
    if (other._handle != _handle) {
        // release my current handle
        _release();
        // adopt the new shareable
        _handle = other._handle;
        // and grab a reference to it
        _acquire();
        // grab the container handle
        _container = other._container;
    }

    // QUESTION: should this go here or in the if statement?
    // invalidate {other} with the bad item of the segmented container
    auto bad_item = segmented_t<shared_ptr_t>::bad_item();
    other = bad_item;

    // all done
    return *this;
}

// interface
template <class Resource>
auto
mito::utilities::SharedPointer<Resource>::_acquire() const -> void
{
    // if the handle is in valid state
    if (_handle != nullptr) {
        // acquire resource (increment reference count)
        _handle->_acquire();
    }

    // all done
    return;
}

template <class Resource>
auto
mito::utilities::SharedPointer<Resource>::_release() const -> void
{
    // if the handle is in valid state
    if (_handle != nullptr) {
        // release my current handle (decreases reference count by one)
        const auto reference_count = _handle->_release();
        // if the resource is now unused
        if (reference_count == 0 && _container != nullptr) {
            // erase it from the container (decrement the number of elements and add the address of
            // the element to the queue of the available locations for reuse)
            return _container->erase(*this);
        }

        // all done
        return;
    }

    // all done
    return;
}

#endif
// end of file
