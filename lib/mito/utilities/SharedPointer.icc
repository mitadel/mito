// -*- C++ -*-
//

#if !defined(mito_utilities_SharedPointer_icc)
#error This header file contains implementation details of class mito::utilities::SharedPointer
#else

// interface
template <class Resource>
mito::utilities::SharedPointer<Resource>::operator mito::utilities::SharedPointer<
    Resource>::handle_t() const
{
    // return the handle
    return _handle;
}

template <class Resource>
auto
mito::utilities::SharedPointer<Resource>::references() const -> int
{
    // return the count of outstanding references
    return _handle->references();
}

template <class Resource>
auto
mito::utilities::SharedPointer<Resource>::reset() -> void
{
    // release my current handle
    _release();

    // invalidate handle
    _handle = nullptr;

    // all done
    return;
}

// operator->
template <class Resource>
auto
mito::utilities::SharedPointer<Resource>::operator->() const
    -> mito::utilities::SharedPointer<Resource>::handle_t
{
    // return the handle
    return _handle;
}

// destructor
template <class Resource>
mito::utilities::SharedPointer<Resource>::~SharedPointer()
{
    // release my current handle
    _release();
}

// default constructor (invalid shared handle)
template <class Resource>
mito::utilities::SharedPointer<Resource>::SharedPointer() : _handle(nullptr)
{}

// the constructor
template <class Resource>
mito::utilities::SharedPointer<Resource>::SharedPointer(handle_t resource) : _handle(resource)
{
    // grab a reference to the shared handle
    _acquire();
}

// the copy constructor
template <class Resource>
mito::utilities::SharedPointer<Resource>::SharedPointer(
    const mito::utilities::SharedPointer<Resource> & other) :
    _handle(other)
{
    // grab a reference to the shared handle
    _acquire();
}

// the move constructor
template <class Resource>
mito::utilities::SharedPointer<Resource>::SharedPointer(
    mito::utilities::SharedPointer<Resource> && other) :
    _handle(other)
{
    // invalidate other
    other._handle = nullptr;
}

// assignment operator
template <class Resource>
mito::utilities::SharedPointer<Resource> &
mito::utilities::SharedPointer<Resource>::operator=(
    const mito::utilities::SharedPointer<Resource> & other)
{
    // if {other} and I point to different handles
    if (other._handle != _handle) {
        // release my current handle
        _release();
        // adopt the new shareable
        _handle = other._handle;
        // and grab a reference to it
        _acquire();
    }

    // all done
    return *this;
}

// move assignment operator
template <class Resource>
mito::utilities::SharedPointer<Resource> &
mito::utilities::SharedPointer<Resource>::operator=(
    mito::utilities::SharedPointer<Resource> && other)
{
    // if {other} and I point to different handles
    if (other._handle != _handle) {
        // release my current handle
        _release();
        // adopt the new shareable
        _handle = other._handle;
    }

    // QUESTION: should this go here or in the if statement?
    // invalidate {other}
    other._handle = nullptr;

    // all done
    return *this;
}

// interface
template <class Resource>
auto
mito::utilities::SharedPointer<Resource>::_acquire() const -> int
{
    // acquire resource
    return _handle->_acquire();
}

template <class Resource>
auto
mito::utilities::SharedPointer<Resource>::_release() const -> int
{
    // if the handle is in valid state
    if (_handle != nullptr) {
        // release my current handle
        return _handle->_release();
    }

    // all done
    return 0;
}

#endif
// end of file
